/***
|''Name''|SharedTiddlersPlugin|
|''Description''|Introduces a possibility to use tiddlers from other ~TiddlyWikis (with or without importing them)|
|''Documentation''|http://yakovl.bplaced.net/TW/STP/STP.html#SharedTiddlersPluginInfo|
|''Type''|plugin|
|''Version''|2.4.0"'|
|''~CoreVersion''|2.2.6|
|''Requires''|UpToDateFiltersPlugin|
|''Requirements note''|[[UpToDateFiltersPlugin|http://yakovl.bplaced.net/TW/ExtraFilters.html#UpToDateFiltersPlugin]] is necessary only for TW below v2.6.2|
|''Source''|http://yakovl.bplaced.net/TW/STP/STP.html#SharedTiddlersPlugin|
|''Author''|Yakov Litvin|
|''Forked from''|[[IncludePlugin|http://tiddlywiki.abego-software.de/#IncludePlugin]], by Udo Borkowski|
|''Contact''|see [[docs|SharedTiddlersPluginInfo]]|
|''Copyright''|Yakov Litvin, 2013|
|''Licence''|[[BSD-like open source license|http://yakovl.bplaced.net/TW/STP/STP.html#%5B%5BYakov%20Litvin%20Public%20Licence%5D%5D]] |
|>| In this tiddler, the code is minified and hidden; the full code can be found [[here|http://yakovl.bplaced.net/TW/STP/STP.html#SharedTiddlersPluginCode]]. |
''Config:''
***/
//{{{
config.options.STP_hijackPrettyLink = true;
config.options.STP_hijackImageFormatter = true;
//}}}
// /%
config.filters.all = function(results,match) {
	if(match[3] == "with included") { // brings included tiddlers as well
		var m,matched = this.reverseLookup();
		for(m = 0; m < matched.length; m++)
			results.pushUnique(matched[m]);
	} else
		this.forEachTiddler(function(tName,tiddler){
			results.pushUnique(tiddler);
		});
	return results;
};
config.filters.includedFrom = function(results,match) {

	var url = twWeb.getStoreUrlById(match[3]);
	if(!url)
		return [];

	for(var i = 0; i < results.length; i++)
		if(results[i].getIncludeURL() != url)
			results.splice(i--,1);
	return results;
};
config.filters.external = function(results,match) {

	for(var i = 0; i < results.length; i++)
		if(!results[i].getIncludeURL())
			results.splice(i--,1);
	return results;
};
config.filters.internal = function(results,match) {

	for(var i = 0; i < results.length; i++)
		if(results[i].getIncludeURL())
			results.splice(i--,1);
	return results;
};

(function(){
//==============================================================================
// install only once stuff

// Ensure the global abego namespace is set up.
if (!window.abego) window.abego = {};

// Install only once (don't install if abego.IncludePlugin is installed as well)
if (abego.TiddlyWikiIncluder)
	return alert("Warning: abego.TiddlyWikiIncluder already exists, so probably two copies of SharedTiddlersPlugin and/or IncludePlugin are installed and activated. It is highly recommended to deactivate all but one copy. You can find those by searching 'abego.TiddlyWikiIncluder'.");

// abego.TiddlyWikiIncluder is defined near the end of the code

// Define the API namespace:
window.sharedTiddlersAPI = {};

//==============================================================================
// Helpers

// This is used instead of displayMessage, because the latter sometimes doesn't show the messages
var displayAndLogMessage = function(text,linkText) {
	displayMessage(text,linkText);
	console.log(text);
};

var invokeLater = function(func, delay, priority) {
	return setTimeout(func,delay);
};

//------------------------------------------------------------------------------
// url helpers

var isRelativeURL = function(url) {
// as Unix filesystem root is "/", urls starting with it are not considered as relative

	return (url.search(/^(?:((http(s)?)|(file)):)|(.\:\\)|(\\\\)|(\/)/) != 0);
};

var getPathFromURL = function(url) {

	return (url.lastIndexOf("/") > -1) ?
		url.substr(0, url.lastIndexOf("/") + 1) : "";
};

var resolveUrlFrom = function(urlToResolve, sourceUrl) {

	return (isRelativeURL(urlToResolve) && sourceUrl) ?
		getPathFromURL(sourceUrl) + urlToResolve : urlToResolve;
};

// limitedly turns URI (URL) reference into an absolute URI (URL) and windows paths into URL
var stp_resolveURL = function(url) {

	if (url.search(/^((http(s)?)|(file)):/) != 0) {
	// no protocol prefix..

		if (isRelativeURL(url))

			url = resolveUrlFrom(url, document.location.toString());
		else
		// "url" is an "absolute" path to a local file. Prefix it with file://

			url = "file://" + url;

		// replace every \ by a /, to cover Windows style pathes
		url = url.replace(/\\/mg,"/");
	}
	return url;
};

//------------------------------------------------------------------------------
// file/tw loading functions

// an evolution of the deprecated loadRemoteFile function with TW 2.7.0 codes
var stp_loadRemoteFile = function(url,callback,params) {
	if(version.major < 2 || version.major == 2 && version.minor < 7) {
		var httpSuccess = function(xhr) {
			try {
				return (!xhr.status && location.protocol === "file:") ||
					(xhr.status >= 200 && xhr.status < 300) ||
					xhr.status === 304 || xhr.status === 1223;
			} catch(e) {}
			return false;
		};
		var options = {
			type:"GET",
			url:url,
			processData:false,
			data:undefined, // cut off?
			cache:false,
			beforeSend: function(xhr) {;},
			complete: function(xhr,textStatus) {
				if(httpSuccess(xhr))
					callback(true,params,xhr.responseText,url,xhr);
				else
					callback(false,params,null,url,xhr);
			}
		};
		try {
			if(window.Components && window.netscape && window.netscape.security && document.location.protocol.indexOf("http") == -1)
				window.netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
		} catch (ex) {}
		return jQuery.ajax(options);
	} else
		return httpReq("GET",url,callback,params);
};

// Asynchronously load the given (local or remote) file.
// 
// @param	url
// value:	either an URL or a local file path to a file
//
//	Examples:
//	* http://www.abego-software.de/index.html
//	* file:///C:/abegoWebSite-Copy/index.html
//	* C:\abegoWebSite-Copy\index.html    (for Windows machines)
//
//	Notice: backslashes in JavaScript string constants must be escaped, 
//	i.e. the last example must be written as: "C:\\abegoWebSite-Copy\\index.html"
//	when "hardcoded" in JavaScript source code.
// 
// @param	callback
// value:	function(content,url,params,errorMessage) 
//		called at the end of the operation. 
//		On success content holds the content of the loaded file. 
//		On error content is undefined and errorMessage holds an error message. 
//		params is the params passed into stp_LoadFile.
//
// @param	params
//		passed through to the callback function
// 
var stp_LoadFile = function(url,callback,params) {

	var onLoad = function(status,params,responseText,url,xhr) {
		return status 
				? callback(responseText, url, params)
				: callback(undefined, url, params, "Error loading %0".format([url]));
	};

	// Make sure the URL is a real URL, with protocol prefix etc.
	url = stp_resolveURL(url);
	
	stp_loadRemoteFile(url,onLoad,params);
};

// Asynchronously load the given (local or remote) TiddlyWiki store.
// 
// @param	url
// value:	either an URL or a local file path to a TiddlyWiki file (absolute or relative)
//
//	Examples:
//	* http://www.abego-software.de/index.html
//	* file:///C:/abegoWebSite-Copy/index.html
//	* include/beta.html
//	* C:\abegoWebSite-Copy\index.html    (for Windows machines)
//
//	Notice: backslashes in JavaScript string constants must be escaped, 
//	i.e. the last example must be written as: "C:\\abegoWebSite-Copy\\index.html"
//	when "hardcoded" in JavaScript source code.
// 
// @param	callbackWithStore
// value:	function(theStore,url,params,errorMessage) 
//			called at the end of the operation. 
//			On success theStore holds the loaded store (a TiddlyWiki object). 
//			On error theStore is undefined and errorMessage holds an error message. 
//			params is the params passed into stp_loadTiddlyWikiStore
//
// @param	params
//		passed through to the callbackWithStore
//
// @param	progress	[optional]
// value:	function(message, sender, state, url, params)
//		called in various situations during the operation,
//		typically used to show "the progress" of the operation.
//		sender: the constant "stp_loadTiddlyWikiStore"
//		state: one of these: "Started", "Processing", "Done", "Failed"
//		"Processing" means the data has been received and in now processed.
// 
var stp_loadTiddlyWikiStore = function(url,callbackWithStore,params,progress) {
	
	var sendProgress = function(message, state) {
		if (progress)
			progress(message,"stp_loadTiddlyWikiStore",state,url,params);
	};
	
	var sendError = function(message) {
		sendProgress("Error when loading %0".format([url]),"Failed");
		callbackWithStore(undefined, url, params, message);
		return message;
	};

	var sendStore = function(store) {
		sendProgress("Loaded %0".format([url]),"Done");
		callbackWithStore(store, url, params);
		return null;
	};
	
	
	var callback = function(content,theURL,params,errorMessage) {
		if (content === undefined) {
			sendError(errorMessage);
			return;
		};
		
		sendProgress("Processing %0".format([url]),"Processing");
		var invalidFileErrorMsg = "The file '%0' does not appear to be a valid TiddlyWiki file";
		try {
			// Load the content from the "content" string into a TiddlyWiki() object
			var importStore = new TiddlyWiki();
			var errorText = importStore.importTiddlyWiki(content)? null :
				"Problem with importing TiddlyWiki, probable reason is: "+
				invalidFileErrorMsg.format([url]);
			if(errorText)
				sendError(errorText);
			else
				sendStore(importStore);
		} catch (ex) {
			sendError(exceptionText(ex));
		};
	};
	
	sendProgress("Start loading %0".format([url]),"Started");
	stp_LoadFile(url,callback,params);
};

//------------------------------------------------------------------------------
// plugin installation helpers

var getArbitraryPluginInfo = function(tiddler) {
// getPluginInfo can't be used (for included tiddlers) because of the ugly slice handling of the core
//  (it uses {store} where it could handle the tiddler directly)
	var pInfo = {};

	var slices = {};
	var requiredInfo = ["Name","Description","Version","Requires","CoreVersion","Date","Source", "Author","License","Browsers"];
	store.slicesRE.lastIndex = 0;
	var match = store.slicesRE.exec(tiddler.text);
	while(match) {
		if(match[2])
			slices[match[2]] = match[3];
		else
			slices[match[5]] = match[6];
		match = store.slicesRE.exec(tiddler.text);
	}
	for(var i = 0; i < requiredInfo.length; i++)
		if(slices[requiredInfo[i]])
			pInfo[requiredInfo[i]] = slices[requiredInfo[i]];
	pInfo.tiddler = tiddler;
	pInfo.title = tiddler.title;
	pInfo.log = [];

	return pInfo;
}

var checkPluginInstalled = function(pluginName) {
	for(var i = 0; i < installedPlugins.length; i++)
		if(installedPlugins[i].title == pluginName || installedPlugins[i].Name == pluginName)
			return true;
	return false;
}

var installPlugin = function(tiddler,force) {

	var pluginName = getArbitraryPluginInfo(tiddler).Name || tiddler.title;
	// check if such a plugin was installed previously, return if so
	if(!force) // two layers to improve the speed in the "force == true" case
		if(checkPluginInstalled(pluginName))
			return;

	// get the plugin info
	var pluginInfo = getArbitraryPluginInfo(tiddler);
	if(tiddler.getIncludeURL())
		pluginInfo.log.push("included from "+tiddler.getIncludeURL());

	// install the plugin
	pluginInfo.executed = true;
	var startTime = new Date();

	try {
		window.eval(tiddler.text);
	} catch(ex) {
		pluginInfo.log.push(config.messages.pluginError.format([exceptionText(ex)]));
		pluginInfo.error = true;
		console.log("error evaluating " + tiddler.title, ex);
		story.displayTiddler(null,"PluginManager");
		displayMessage(config.messages.customConfigError);
	}
	pluginInfo.startupTime = String((new Date()) - startTime) + "ms";

	// register the plugin
	installedPlugins.push(pluginInfo);
}


//==============================================================================
// Shared Tiddlers Plugin

// Constants

var WAITING = "waiting";
var LOADING = "loading";

var ANI_DURATION_HIDE_STATE = 1000;

var REFRESH_PRIORITY = -200;
var ANIMATION_PRIORITY = -100;
var UPDATE_STATE_PRIORITY = -300;

// --------------------------------------------------
// Variables

var useInclude;         // this variable can be used to control include enabling by other things than cookies
var includedStores = {};  // url(String) -> TiddlyWiki or String; if not (yet) loaded a status or an error string
var pendingOnLoadURLs = []; // [] of String: a list of urls that should be passed with the next "notifyListeners"
var refreshTiddlyWikiTimerID; // for delayed refresh
var listeners = [];
var progress;

// rules pointing which stores tiddlers with conflicting names should be fetched from
function FetchPreferences() {
	var prefs = {};
	
	this.add = function(tiddlerName,sourceUrl,substitute,substituteShadow) {
		if(!substitute && !substituteShadow)
			return;
		if(prefs[tiddlerName] == undefined)
			prefs[tiddlerName] = {urlsSubs: [], urlsSubsSh: []};
		if(substitute)
			prefs[tiddlerName].urlsSubs.pushUnique(sourceUrl);
		if(substituteShadow)
			prefs[tiddlerName].urlsSubsSh.pushUnique(sourceUrl);
	};
/*	this.getPrefs = function(tiddlerName) {
		return jQuery.extend(true, {}, prefs[tiddlerName]);
	};
*/	this.getSubsUrl = function(tiddlerName) {
		var pref = prefs[tiddlerName];
		if(pref == null)
			return null;
		if(pref.urlsSubs.length == 0)
			return null;
		return pref.urlsSubs[0];
	};
	this.getSubsShUrl = function(tiddlerName) {
		var pref = prefs[tiddlerName];
		if(pref == null)
			return null;
		if(pref.urlsSubsSh.length == 0)
			return null;

		// check if there's a tiddler with both preferences
		var i, j;
		for(i = 0; i < pref.urlsSubs.length; i++)
			for(j = 0; i < pref.urlsSubsSh.length; j++)
				if(pref.urlsSubs[i] == pref.urlsSubsSh[j])
					return pref.urlsSubs[i];

		return pref.urlsSubsSh[0];
	};
	this.containSubsUrl = function(tName,url) {
		var pref = prefs[tName];
		if(pref == null)
			return false;
		return pref.urlsSubs.contains(url);
	};
	this.containSubsShUrl = function(tName,url) {
		var pref = prefs[tName];
		if(pref == null)
			return false;
		return pref.urlsSubsSh.contains(url);
	};
	this.removeByUrl = function(url) {  // removes all priorities of tiddlers, included from the url

		var tName, pref, i;

		for(tName in prefs) {
			pref = prefs[tName]
			for(i = 0; i < pref.urlsSubs.length; i++)
				if(pref.urlsSubs[i] == url)
					pref.urlsSubs.splice(i--,1);
			for(i = 0; i < pref.urlsSubsSh.length; i++)
				if(pref.urlsSubsSh[i] == url)
					pref.urlsSubsSh.splice(i--,1);
			// if (pref.urlsSubs.length == 0 && pref.urlsSubsSh.length == 0), not nec. to delete pref
		}
	};
};
var fetchPreferences = new FetchPreferences();

function Conflicts() {

	// hashmaps by tiddler name of potentially conflicting tiddlers with that name;
	// each element is a hashmap by url of tiddlers with such names
	var pConfs = {},  // doesn't contain info about tiddlers in the main store
	    pSConfs = {}; // for tiddlers that may conflict when substituting a shadow

	this.init = function() {
		// notify of name conflicts in the whole set of initial and included tiddlers?
		if(config.options.chkWarnOnSharedTiddlersConflicts == undefined) config.options.chkWarnOnSharedTiddlersConflicts = true;
		// use alert() for notifications?
		if(config.options.chkAlertOnSharedTiddlersConflicts == undefined) config.options.chkAlertOnSharedTiddlersConflicts = false;
	};
	// check whether a new tiddler (not included yet) may cause a conflict (now or in the future)
	this.checkNew = function(tName, url, subs, subsSh) {

		// use to add when a tiddler with such name is already present
		var addData = function(confsMap, tidParams) {

			var includeData = function(tidParams) {		// better to create a separate class
				return { subs: tidParams.substitute, warned: false };
			};
			var getSubsPriority = function(data) {
				return data.subs;
			}

			var conf = confsMap[tidParams.title];
			if(!conf) {
				conf = confsMap[tidParams.title] = {};
				conf[tidParams.url] = includeData(tidParams);
			} else {
				var confPart = conf[tidParams.url];
				if(!confPart)
					conf[tidParams.url] = includeData(tidParams);
				else {
					if(!getSubsPriority(confPart) && tidParams.substitute)
						conf[tidParams.url] = includeData(tidParams);
						// better to set subs to true and warned to false
				}
			}
		}

		// check if there's a tiddler with such a name
		var existingTid = forEachLoadedStore(function(theStore, storeUrl) {	// in included stores
			if(storeUrl != url)
				return theStore.fetchTiddler(tName);
		}) || window.sharedTiddlersAPI.orig_fetchTiddler(tName);		// or in the main one
		// if the tiddler is added to the main store after exactly one tiddler is included, no conflict is
		// detected by this algorithm; also, it doesn't account deleting the tiddler from the main store

		if(!existingTid)
			return;
		var mainStoreId = "main store",
		    existingTidUrl = existingTid.getIncludeURL();

		// check conflicts among all included tiddlers (important when no shadow with such name exists)
		if(!pConfs[tName])
			addData(pConfs, {
				title: tName,
				url: existingTidUrl || mainStoreId,
				substitute: existingTidUrl ? fetchPreferences.containSubsUrl(tName,existingTidUrl) : undefined
			});
		addData(pConfs, { title: tName, url: url, substitute: subs });

		// check conflicts among tiddlers that substitute a shadow
		if(subsSh) {
			var existingTidSubsSh = forEachLoadedStore(function(theStore, storeUrl) {
				if(storeUrl != url && fetchPreferences.containSubsShUrl(tName,storeUrl))
					return theStore.fetchTiddler(tName);
			}) || window.sharedTiddlersAPI.orig_fetchTiddler(tName);
			// same problems
			
			if(!existingTidSubsSh)
				return;
			var existingTidSubsShUrl = existingTidSubsSh.getIncludeURL();

			// conflicts among substituting tiddlers are important when a shadow with such name exists
			if(!pSConfs[tName])
				addData(pSConfs, {
					title: tName,
					url: existingTidSubsShUrl || mainStoreId,
					substitute: existingTidSubsShUrl ? fetchPreferences.containSubsShUrl(tName,existingTidSubsShUrl) : undefined
				});
			addData(pSConfs, { title: tName, url: url, substitute: subs });
		}
	};
	this.markNodeUnloaded = function(url) {
		var t;
		for(t in pConfs)
			if(pConfs[t][url])
				delete pConfs[t][url];
		for(t in pSConfs)
			if(pSConfs[t][url])
				delete pSConfs[t][url];
	};
	this.notify = function() {
		var msgAndLog = config.options.chkWarnOnSharedTiddlersConflicts;
		var doAlert   = config.options.chkAlertOnSharedTiddlersConflicts;
		if(!doAlert && !msgAndLog)
			return; // no conflict is marked as "warned" - this is by intent
		var tName, tUrl;

		var checkOrDisplayConflicts = function(map,msgAndLog,markWarned) {
			var msg = ""; // message to return (for alerting etc)
			var addM = function(m) { // pushes all notification messages
				msg += ("\n"+m);
				if(msgAndLog)
					displayAndLogMessage(m);
			};
			var tName, tSources, tUrl, subs, nOfConflicting, newPresent,
				subsMsg = "  (with the subsitute priority)";
				// mark conflicts among tiddlers with the substitute priority

			// find out where necessary, notify
			for(tName in map) {
				tSources = map[tName];

				// find out which priority is of interest
				subs = false;
				for(tUrl in tSources)
					if(tSources[tUrl].subs)
						subs = true;

				// if there's only one tiddler with "substitute", there's no conflict
				nOfConflicting = 0;
				for(tUrl in tSources)
					if(tSources[tUrl].subs == subs)
						nOfConflicting++;
				if(nOfConflicting < 2)
					break;

				// find out if new conflicting tiddlers are present
				newPresent = false;
				for(tUrl in tSources)
					if(tSources[tUrl].subs == subs && !tSources[tUrl].warned)
						newPresent = true;

				// start notification
				if(newPresent) {
					addM("* "+tName+" in:");
					for(tUrl in tSources)
						if(tSources[tUrl].subs == subs && !tSources[tUrl].warned) {
							addM("** "+tUrl);
							if(markWarned)
								tSources[tUrl].warned = true;
						}
					if(subs)
						addM(subsMsg);
				}
			}
			return msg;
		};

		var msg = "";
		if(checkOrDisplayConflicts(pConfs,false,false)) { // new conflicts present
			msg += "New conflicts:";
			if(msgAndLog) displayAndLogMessage(msg);
			msg += checkOrDisplayConflicts(pConfs,msgAndLog,true);
		};
		if(checkOrDisplayConflicts(pSConfs,false,false)) { // new conflicts among tiddlers substituting shadows present
			if(msg) msg += "\n";
			var m = "New conflicts among tiddlers competing for substituting shadows:";
			msg += m;
			if(msgAndLog) displayAndLogMessage(m);
			msg += checkOrDisplayConflicts(pSConfs,msgAndLog,true);
		};
		if(doAlert && msg)
			alert(msg);
	};
//	this.state = // return current state as a string (for includeState)
};
conflicts = new Conflicts();
conflicts.init();

// --------------------------------------------------
// Helper functions

var isIncludeEnabled = function() {
	if (useInclude === undefined)
		useInclude = config.options.chkUseInclude === undefined || config.options.chkUseInclude;
	return useInclude;
};

var getMissingIncludeMsg = function(url) {
	return "No include specified for %0".format([url])
};

// Called after one or more included TiddlyWikis are loaded
//
var notifyListeners = function() {
	var urls = pendingOnLoadURLs;
	pendingOnLoadURLs = [];
	if (urls.length)
		for (var i = 0; i < listeners.length; i++)
			listeners[i](urls);
};

var idleCount; // Reset to 0 when the system is "not idle", incremented inside refreshTiddlyWiki

var refreshTiddlyWiki = function() {
	// To avoid to much refreshing/flickering don't refresh immediately 
	// but wait until the system was idle for a certain time.

	if (refreshTiddlyWikiTimerID !== undefined) clearInterval(refreshTiddlyWikiTimerID);

	idleCount = 0;

	var sendDone = function() {
		twWeb.sendProgress("","","Done");
	};

	refreshTiddlyWikiTimerID = setInterval(function() {
		idleCount++;
		if (idleCount <= 10)
			return;

		clearInterval(refreshTiddlyWikiTimerID);
		refreshTiddlyWikiTimerID = undefined;

		twWeb.sendProgress("Refreshing...","","");
		refreshDisplay();
		invokeLater(sendDone,0,REFRESH_PRIORITY);
	},1);
};

// Calls callback for every loaded store and returns the first non-false/null.. value returned by callback.
//
// @param	callback
// value:	function(store, url)
//
var forEachLoadedStore = function(callback) {
	var result;
	for(var url in includedStores) {
		var theStore = twWeb.getStore(url);
		if (theStore && (result = callback(theStore, url)))
			return result;
	}
};

// hijack fetchTiddler so that it works with tiddlers from included stores as well
var attachToStore = function() {
	if (!window.store)
		return invokeLater(attachToStore,100);

	var orig_fetchTiddler = store.fetchTiddler;
	window.sharedTiddlersAPI.orig_fetchTiddler = orig_fetchTiddler;
	// reserve access to the original method to be able to fetch tiddlers from main store,
	// including substituted ones

	store.fetchTiddler = function(title) {
		var t, subsUrl = fetchPreferences.getSubsUrl(title), subsShUrl;

		// first, look for the tiddler in the main store, unless there's nothing to substitute with
		if(!subsUrl) {
			t = orig_fetchTiddler.apply(this,arguments);
			if(t) return t;
		} else
			return includedStores[subsUrl].fetchTiddler(title);
		
		// then, look for shadowed tiddlers in main store and external ones to substitute those
		if(config.shadowTiddlers[title] !== undefined) {
			if(subsShUrl = fetchPreferences.getSubsShUrl(title))
				return includedStores[subsShUrl].fetchTiddler(title);
			else
				return undefined;
		};

		// Don't look for the "New Tiddler" tiddler in the included TiddlyWikis,
		// since returning such a tiddler (that is readonly) will make it impossible
		// in the Main TiddlyWiki to create new tiddlers via standart "new tiddler" button.
		if (title == config.macros.newTiddler.title) return undefined;

		// finally, look for an external one without "substitute" preference
		return forEachLoadedStore(function(theStore, url) {
			return theStore.fetchTiddler(title);
		});
	};

	// refresh TiddlyWiki to reflect the new included Tiddlers (if we have any).
	if(twWeb.getIncludedStoresUrls().length)
		refreshTiddlyWiki();
};

var includeFromIncludeList = function() {
	if (!window.store)
		return invokeLater(includeFromIncludeList,100);
	
	var includeListText = store.getTiddlerText("IncludeList");
	if (includeListText)
		wikify(includeListText,document.createElement("div"),undefined,store.fetchTiddler("IncludeList"));
};

var getFunctionUsingForReallyEachTiddler = function(func) {
	var wrapper = function() {
		var orig_forEachTiddler = store.forEachTiddler;

		var forEachTiddlerWithIncludes = function(callback) {
			var done = {};

			var callbackWrapper = function(title, tiddler) {
				// ensure every title is only processed once
				if(done[title]) 
					return;
				
				// do and set done for appropriate tiddlers
				if(!fetchPreferences.getSubsUrl(title)||
				   (fetchPreferences.getSubsUrl(title) == tiddler.getIncludeURL())) {
					done[title] = 1;
					callback.apply(this,arguments);
				};
			};
			
			// first, forEachTiddler over the original tiddlers
			orig_forEachTiddler.call(store, callbackWrapper);
			
			// add nonsubstituted shadowTiddler titles to done 
			// (to avoid an included store hide a shadow tiddler)
			for (var n in config.shadowTiddlers)
				if(!fetchPreferences.getSubsShUrl(n))
					done[n] = 1;

			// add the "New Tiddler" tiddler to done
			// to avoid an included store (with such tiddler) prevent creating new tiddlers
			done[config.macros.newTiddler.title] = 1;

			// forEachTiddler over every included store
			forEachLoadedStore(function(theStore, url) {
				theStore.forEachTiddler(callbackWrapper);
			});
		};
		
		store.forEachTiddler = forEachTiddlerWithIncludes;
		try {
			return func.apply(this,arguments);
		} finally {
			store.forEachTiddler = orig_forEachTiddler;
		};
	};
	
	return wrapper;
};

var useForReallyEachTiddler = function(object,property) {
	return object[property] = getFunctionUsingForReallyEachTiddler(object[property]);
};


//================================================================================
// config.extensions.SharedTiddlersPlugin (the "includer" engine)

config.extensions.SharedTiddlersPlugin = {

	// function config.extensions.SharedTiddlersPlugin.getFunctionUsingForReallyEachTiddler(func)
	//
	// Returns a function that behaves as func, but every call to store.forEachTiddler will actually 
	// be a call to forReallyEachTiddler (see below), i.e. iterate over the tiddlers of the main store 
	// and of the included TiddlyWikis
	//
	// @return the patched function
	//
	getFunctionUsingForReallyEachTiddler: getFunctionUsingForReallyEachTiddler,
	
	// function config.extensions.SharedTiddlersPlugin.useForReallyEachTiddler(object,property)
	//
	// Patches the function hold in the given property of the object in such a way that every call
	// to store.forEachTiddler will actually be a call to forReallyEachTiddler (see below), i.e.
	// iterate over the tiddlers of the main store and of the included TiddlyWikis
	//
	// @param  object
	// @param  property the name of the property of the object containing the function to be patched.
	// @return the patched function
	//
	useForReallyEachTiddler: useForReallyEachTiddler,
	
	// Add a listener function to the TiddlyWikiIncluder.
	//
	// @param  listener  function(urls)
	//			urls: [] of Strings, containing the urls of the TiddlyWiki just included
	//			(see url@config.extensions.SharedTiddlersPlugin.include)
	//			called whenever one or more TiddlyWiki store are successfully included.
	//
	addListener: function(listener) {
		listeners.push(listener);
	}
};


// -------------------------------------------------------------------------------
// TiddlyWikiIncluder initialization code

config.extensions.SharedTiddlersPlugin.addListener(refreshTiddlyWiki);

config.shadowTiddlers.AdvancedOptions +=
	("\n~IncludePlugin settings:"+
	 "\n<<option chkUseInclude>> Include ~TiddlyWikis"+
	 "\n<<option chkAlertOnSharedTiddlersConflicts>> Alert on tiddler name conflicts"+
	 "\n<<option chkWarnOnSharedTiddlersConflicts>> Display messages and write log in the browser console on conflicts"+
	 "\nIncludeList | IncludeState | ImportIncluded | [[help|http://yakovl.bplaced.net/TW/SharedTiddlersPlugin.html/#SharedTiddlersPluginInfo]]"+
	 "\n^^(Reload this ~TiddlyWiki to make changes become effective)^^");
config.shadowTiddlers.IncludeState = "<<includeState>>";

// add the "importer" engine
config.shadowTiddlers.ImportIncluded =
"| the url of the document to import from | <<option txtStoreUrl>>               |\n"+
"|    the filter of tiddlers to import    | <<option txtFilterTiddlersToImport>> |\n"+
"|           the importing mode           | <<option txtImportMode>>             |\n"+
"<html><a href='javascript:;' onclick='\n"+
"	var storeUrl = config.options.txtStoreUrl,\n"+
"	    params = {\n"+
"		filterLine: config.options.txtFilterTiddlersToImport,\n"+
"		importMode: config.options.txtImportMode,\n"+
"		noRefresh: true,\n"+
"	};\n"+

"	if(!storeUrl)\n"+
"		return displayMessage(\"please specify the url to import from\");\n"+
"	if(!params.filterLine)\n"+
"		return displayMessage(\"please specify the filter of tiddlers to import\");\n"+
"	if(!sharedTiddlersAPI.getStore(storeUrl))\n"+
"		displayMessage(\"warning: no store was loaded from \"+storeUrl+\" previously, trying now\");\n"+

"	twWeb.include(storeUrl,params);\n"+
"'>import (without saving)<a/></html>";

//================================================================================
// Tiddler extension/modification

Tiddler.prototype.isIncluded = function() {
	return this.includeURL != undefined;
};

Tiddler.prototype.getIncludeURL = function() {
	return this.includeURL;
};

Tiddler.prototype.setIncludeURL = function(url) {
	this.includeURL = url;
};

Tiddler.prototype.deleteIncludeURL = function() {
	delete this.includeURL;
};

// make included tiddlers readonly
config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly = Tiddler.prototype.isReadOnly;

Tiddler.prototype.isReadOnly = function() {
	return config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly.apply(this,arguments) || this.isIncluded();
}

//================================================================================
// TiddlyWiki modifications

// In some TiddlyWiki functions the "forEachTiddler" should work on all tiddlers, also those from 
// included store. (E.g. TiddlyWiki.prototype.getTags)
//
// But not for all (e.g. TiddlyWiki.prototype.getTiddlers is used for saving, but only the "own" tiddlers should be saved)
//
// Therefore explicitly list the functions that should be "wrapped" to use the "forReallyEachTiddler".
//
var tiddlyWikiFunctionsUsingForReallyEachTiddler = {
	getMissingLinks: 1, getOrphans: 1,
	getTags: 1, reverseLookup: 1, updateTiddlers: 1};
	
for (var n in tiddlyWikiFunctionsUsingForReallyEachTiddler)
	useForReallyEachTiddler(TiddlyWiki.prototype,n);

//================================================================================
// Web of TiddlyWikis

function IncludingMemorizer() { // the structure to store info about already handled include macros
	var used = {};
	this.isUsed  = function(line) { return used[line]? true : false; };
	this.setUsed = function(line) { used[line] = 1; };
	this.getUsed = function() { return jQuery.extend(true, {}, used) };
	this.markUnused = function(usedMap) {

		for(var u in usedMap)
			used[u] = undefined; // don't delete to keep the order of inclusion (for reloading)
	};
};

function TwWeb() {

	var nodes = {};			// hashmap by node name of nodes' metadata
	var nodeConflicts = {};		// hashmap by node name of arrays of conflicts
	var nodeWaitingTasks = {};	// hashmap by node name of arrays of Waiting Tasks
	var nodeDescription = function(url) { // PoG: can be turned into a separated "class"
		return { url : url };
	};
	var selfNodeName;
	var self = this;

	this.includeUsages = new IncludingMemorizer();

// ----- Nodes desctiptions part ---------------------------------------------------------------------

	// set/get the name of "main" (including) node
	this.setSelfNodeName = function(name) {
		selfNodeName = name;
	};
	this.getSelfNodeName = function() {
		return selfNodeName;
	};

	// set/get/delete node description
	this.setNodeDesc = function(nodeName, desc) {

		var existing = this.getNodeDesc(nodeName);

		// currently, doesn't change metadata on conflict
		if(existing)
			this.addConflict(nodeName, desc);
		else
			nodes[nodeName] = desc;

		this.callWaitingTasks(nodeName);
	};
	this.getNodeDesc = function(nodeName) {
		return nodes[nodeName];
	};
	this.deleteNodeDesc = function(nodeName) {
		nodes[nodeName] = null;
	};

	// "API" method to be used in the macro
	this.addNodeDesc = function(nodeName, url) {
		this.setNodeDesc(nodeName, nodeDescription(url));
	};

	// returns "better" description if one is "strictly better" than the other or "even" and null otherwise
	this.compareNodeDesc = function(desc1, desc2) {

// looks like here's a mistake: probably ": desc2" (?)
		return (desc1.url == desc2.url)? desc1 : null;
	};

	this.getNodeUrl = function(nodeName) {

		var desc = this.getNodeDesc(nodeName);
		return desc? desc.url : null;
	};

	// @param	nodeId
	//		url or "node: nodeName" id of the node
	// @return	url of the node (if it is defined) or null
	//
	this.getStoreUrlById = function(nodeId) {

		var node = self.checkNodeNotation(nodeId),
		    url  = node ? self.getNodeUrl(node) : nodeId;
		return url;
	}

	this.setNodeNotation = function(nodeName) {

		return "node: " + nodeName;
	};
	this.checkNodeNotation = function(urlParam) {

		var nodeCalcRE = /node: (.*)/,
		    nodeCalcMatch = nodeCalcRE.exec(urlParam);

		return nodeCalcMatch ? nodeCalcMatch[1] : null;
	};

	this.addConflict = function(nodeName, nodeDesciption) {

		var betterDesc = this.compareNodeDesc(nodeDesciption,this.getNodeDesc(nodeName));
		if(betterDesc) {
			this.deleteNodeDesc(nodeName);
			this.setNodeDesc(nodeName, betterDesc);
			return;
		}

		if(nodeConflicts[nodeName])
			nodeConflicts[nodeName].push(nodeDesciption);
		else
			nodeConflicts[nodeName] = [ nodeDesciption ];

		alert(  "Warning: more than one description of the "+nodeName+" node was pushed. "+
			"The earlier version is kept."  );
	};

// ----- Waiting tasks part --------------------------------------------------------------------------

	this.setWaitingTask = function(nodeName, waitingTaskFunc, waitingTaskSelf) {

		var waitingTask = { action: waitingTaskFunc, self: waitingTaskSelf };

		if(nodeWaitingTasks[nodeName])
			nodeWaitingTasks[nodeName].push(waitingTask);
		else
			nodeWaitingTasks[nodeName] = [ waitingTask ];

		if(this.getNodeUrl(nodeName))
			this.callWaitingTasks(nodeName);
	};
	this.callWaitingTasks = function(nodeName) {

		var toDo = nodeWaitingTasks[nodeName];

		if(toDo)
			for(var i = 0; i < toDo.length; i++)
				toDo[i].action.call(toDo[i].self);

		nodeWaitingTasks[nodeName] = null; // remove called Waiting Tasks
	};

// ----- Including stuff part ------------------------------------------------------------------------

	// ---- helpers ----

	this.setProgressFunction = function(func) {
		progress = func;
	};
/*	this.getProgressFunction = function() {	// is not in use
		return progress;
	};
*/	this.sendProgress = function(message, sender, state) {
		if (progress)
			progress.apply(this,arguments);
	};

	// Returns true when there are "pending" includes, i.e. TiddlyWiki that are not yet loaded.
	// A TiddlyWiki that failed loading is not pending.
	//
	this.hasPendingIncludes = function() {
		var state;
		for(var url in includedStores) {
			state = this.getState(url);
			if (state == WAITING || state == LOADING)
				return true;
		};
		return false;
	};

	// Called when an included TiddlyWiki could not be loaded.
	// By default an error message is displayed.
	//
	this.onError = function(url, errorMessage) {
		displayAndLogMessage("Error when including '%0':\n%1".format([url, errorMessage]));
	};

	// import a tiddler from an included store
	//
	// @param  tiddler - a tiddler to import
	// @param  mode: undefined or 1 - import anyway (other modes, like "don't substitute" will be supported)
	// @return the result object:
	//  .status means: -1 = error, 0 = tiddler is imported, >0 - reserved for other situations
	//  .errorText is not empty on error
	//  .tiddler is the tiddler with /the title/ which is in the store after "it is over" (may be null)
	//  .from is the url line equal to the includeURL of the imported tiddler
	//
	this.importIncluded = function(tiddler,mode) {

		if(mode == undefined)
			mode = 1;
		else
			mode = parseInt(mode);

		var t, tInMain, result = { tiddler: null };
		var doImport = function(t) {
			store.addTiddler(t);
			store.setDirty(true);
			result.status = 0;
			result.tiddler = t;
			result.from = url;
		};

		if(tiddler instanceof Tiddler) {
			// see return value, this is for the case when the import is not done
			result.tiddler = window.sharedTiddlersAPI.orig_fetchTiddler(tiddler.title);
			t = jQuery.extend(true, new Tiddler(), tiddler);
		} else {
			result.status = -1;
			result.errorText = "not a Tiddler instance";
			return result;
		};
		var url;
		if(url = t.getIncludeURL())
			t.deleteIncludeURL();

		switch(mode) {
			case 4: { // import only newer and on confirm
				tInMain = window.sharedTiddlersAPI.orig_fetchTiddler(t.title);
				if(!tInMain || tInMain.modified < t.modified)
					if(confirm("Up-to-date "+t.title+" from "+url+" is availabe, import?"))
						doImport(t);
				break
			}
			case 2: { // import only newer versions/unexisting tiddlers
				tInMain = window.sharedTiddlersAPI.orig_fetchTiddler(t.title);
				if(!tInMain || tInMain.modified < t.modified)
					doImport(t);
				break
			}
			case 3: { // import on confirm
				if(confirm(t.title+" from "+url+" is availabe, import?"))
					doImport(t);
				break
			}
			case 1: { // import anyway
				doImport(t);
				break
			}
			default: {
				result.status = -1;
				result.errorText = "unknown import mode";
			}
		};
		return result;
	};
	this.importAndLog = function(tiddler,mode) {

		var name   = tiddler.title,
		    result = twWeb.importIncluded(tiddler,mode);
		// this.importIncluded is not used to be able to pass the method to the API

		switch(result.status) {
			case 0:	 console.log("imported: "+name+" from "+result.from);
				 break
			case -1: console.log("error importing "+name+": "+result.errorText);
				 break
		}
	};

	// ---- main ----

	// Includes the (local or remote) TiddlyWiki store with the given url.
	//
	// @param url		see url@stp_loadTiddlyWikiStore
	// @param includeParams	a set of the following params for including:
	//	filterLine		a filter expression defining a set of tiddlers to include
	//	substituting		points whether an included tiddler should sustitute
	//				one in the main document if there's a conflict of names
	//	substituteShadows	points whether shadowed tiddlers of the main document with names equal to
	//				those of included ones should be substituted (in cases of conflicts);
	//				works only with (substituting == true)
	//	delayMilliSeconds	addition delay of loading
	//	noRefresh
	//	importMode
	//	evalTiddlers
	//	wikifyTiddlers
	//
	this.include = function(urlOrNodeParam, includeParams) {

		if (!isIncludeEnabled())
			return;
		var self = this;

		var includeOrHandleUrl = function(url) {

			var loadStoreCallback = function(theStore,urlInCallback,params,errorMessage) {

				if(theStore === undefined) {
				
					includedStores[url] = errorMessage;
					self.onError(url, errorMessage);
					return;
				} else
					includedStores[url] = theStore;

				// keep orig_store not to load tw-documents multiple times
				// because of multiple include macros:
				includedStores[url].orig_store = new TiddlyWiki();
				includedStores[url].forEachTiddler(function(tName,tiddler){
					tiddler.setIncludeURL(url);
					includedStores[url].orig_store.addTiddler(tiddler);
				});
				includedStores[url].clear();

				// include, create fetchPreferences and notify of conflicts; or import
				addFromLoadedStore();
			};

			var addFromLoadedStore = function() {
			// uses url and includeParams exploiting closure

				var substituting = includeParams.substitute,
				    substituteShadows = includeParams.substituteShadows,
				    importMode = includeParams.importMode;

				if(twWeb.getStore(url) === null)
					return invokeLater(addFromLoadedStore, 100);	// 100 milliseconds
				// new tiddlers should be added *when the store is loaded*

				// add tiddlers to included stores and check new conflicts (among non-subs. tids)
				var i, t,
				    new_tiddlers = includedStores[url].orig_store.filterTiddlers(includeParams.filterLine);

				for(i = 0; i < new_tiddlers.length; i++) {

					t = jQuery.extend(true, new Tiddler(), new_tiddlers[i]); //copy (by value)

					if(includedStores[url].orig_store.fetchTiddler(t.title)) {
					// ignore empty tiddlers created by the "tiddler" filter
					    if(importMode)
					        twWeb.importAndLog(t,importMode);
					    else {
					        // check for upcoming conflicts first
					        conflicts.checkNew(t.title, url, substituting, substituteShadows);
					        // then include
					        includedStores[url].addTiddler(t);
					    };
					    if(includeParams.evalTiddlers)
					        installPlugin(t);
					    if(includeParams.wikifyTiddlers)
					        wikify(t.text,document.createElement("div"),undefined,t);
					};
				};

				// add items to fetchPreferences if have to
				if(!importMode && (substituting || substituteShadows))
					for(i = 0; i < new_tiddlers.length; i++)
						fetchPreferences.add(new_tiddlers[i].title,url,substituting, substituteShadows);
				conflicts.notify();

				// "recalc" slices
				store.slices = {};
				// refresh things to get included stylesheets, PageTemplate and ViewTemplate applied
				if(!includeParams.noRefresh) {
					refreshAll();
					story.refreshAllTiddlers();
				}

				pendingOnLoadURLs.push(url);
				invokeLater(notifyListeners);
			};

			var loadStore = function() {
				includedStores[url] = LOADING;
				stp_loadTiddlyWikiStore(url,loadStoreCallback,null,progress);
				// {includeParams:includeParams} can be used instead of null so that
				// loadStoreCallback will have access to the includeParams
			};

			var urlIsNew = !(includedStores[url]);

			if(urlIsNew) {

				includedStores[url] = WAITING;

				if (includeParams.delayMilliSeconds)
					invokeLater(loadStore, includeParams.delayMilliSeconds);
				else
					loadStore();
			} else
				addFromLoadedStore();
		};

		var nodeName = this.checkNodeNotation(urlOrNodeParam);

		if(nodeName) {
			if(nodeName == this.getSelfNodeName()) // don't include from the main (self) TiddlyWiki
				return;
			this.setWaitingTask(nodeName,function(){
				var url = this.getNodeUrl(nodeName);
				includeOrHandleUrl(url);
			},this);
		} else
			includeOrHandleUrl(urlOrNodeParam);
	};
	
// ----- Methods for dealing with included stuff -----------------------------------------------------

	// @return [] of Strings, the URLs of the includes
	//
	this.getIncludedStoresUrls = function() { // in a form of an array

		var includes = [];
		for(var url in includedStores)
			includes.push(url);
		return includes;
	};
	// @return the (TiddlyWiki) store with the given URL or "node: nodeName", or null if not (yet) loaded.
	//
	this.getStore = function(nodeId) {

		var url = self.getStoreUrlById(nodeId)
		if(!url)
			return null;

		var s = includedStores[url];
		if(s && s instanceof TiddlyWiki)
			return s;
		return null;
	};
	// @return a state/error text of the store with the given URL, or null when the store is already loaded
	//
	this.getState = function(nodeId) {

		var url = self.getStoreUrlById(nodeId)
		if(!url)
			return "the node "+self.checkNodeNotation(nodeId)+" is not described yet, the address is unknown";

		var s = includedStores[url];
		if (!s)
			return getMissingIncludeMsg(url);
		return typeof s == "string" ? s : null;
	};
	// reload one included store or all of them
	// previous inclusions are done again, by default only those without eval and import
	// important: reload doesn't work correctly with <<include>> usages with multiple urls
	//
	// @param  reloadParams  an object containing some of these configuration properties:
	//	urlOrNodeList	an array of TWs' IDs (url or "node: nodeName") to reload;
	//			if undefined, all TWs are reloaded
	//	eval		points whether to redo inclusions with the "eval" parameter (undefined == false)
	//	import		same for the "import" parameter, but undefined/null -> true
	//	wikify		same for the "wikify" parameter
	this.reload = function(reloadParams) {

		// determine a TW(s) to reload (undefined => all)
		var i, twsToReload = reloadParams.urlOrNodeParam;

		// turn "IDs" into actual urls; filter out node names for which urls are not defined
		// so waiting tasks are not doubled
		if(twsToReload)
			for(i = 0; i < twsToReload.length; i++){ 
				nodeName = this.checkNodeNotation(twsToReload[i]);
				twsToReload[i] = nodeName ? this.getNodeUrl(nodeName) : twsToReload[i];
				if(!twsToReload[i])
					twsToReload.splice(i--,1);
			}

		if(reloadParams.import === undefined || reloadParams.import === null)
			reloadParams.import = true;
		if(reloadParams.wikify === undefined || reloadParams.wikify === null)
			reloadParams.wikify = true;

		// collect macro expressions to reload
			// may the order of including be important?
		var usage, usages = this.includeUsages.getUsed(),
		    paramString, params, pParams, urlParam, nodeName,
			dontReload, i;

		for(usage in usages) {

			// parsing copied from config.macros.include.handler (to get macro params)
			paramString = usage.substring(10,usage.length - 2);
			params = paramString.readMacroParams();
			pParams = paramString.parseParams("url",null,true,false,true);
			urlParam = pParams[0]["url"][0];
			nodeName = this.checkNodeNotation(urlParam);
			urlParam = nodeName ? this.getNodeUrl(nodeName) : urlParam;

			// keep only inclusions that contain IDs corresponding to urls from twsToReload
			dontReload = true;
			if(twsToReload) {
				for(i = 0; i < twsToReload.length; i++)
					if(urlParam == twsToReload[i])
						dontReload = false;
			} else
				dontReload = false;

			// exclude inclusions with import and eval, if necessary
			if(!reloadParams.import && getParam(pParams,"import",undefined) ||
			   !reloadParams.eval && params.contains('eval') ||
			   !reloadParams.wikify && params.contains('wikify'))
				dontReload = true;

			if(dontReload) {
				delete usages[usage];
				continue;
			}

			// clean stuff: unload included store, clear priorities, remove conflicts;
			// deleting "used" marks is outside this loop
			includedStores[urlParam] = undefined;
			fetchPreferences.removeByUrl(urlParam);
			conflicts.markNodeUnloaded(urlParam);
		}
		// delete "used" marks
		this.includeUsages.markUnused(usages);
		
		// include again
		for(usage in usages)
			wikify(usage,document.createElement("div"),undefined,null);
	};
};
twWeb = new TwWeb();

//================================================================================
// Default Progress Handling for config.extensions.SharedTiddlersPlugin

var showAnimated = function(e, showing, duration) {
//	if (!anim || !abego.ShowAnimation) {
		e.style.display = showing ? "block" : "none";
		return;
//	}
	
//	anim.startAnimating(new abego.ShowAnimation(e,showing,duration));
};

config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction = function() {

	setStylesheet(
		".includeProgressState{\n"+
		"background-color:#FFCC00;\n"+
		"position:absolute;\n"+
		"right:0.2em;\n"+
		"top:0.2em;\n"+
		"width:7em;\n"+
		"padding-left:0.2em;\n"+
		"padding-right:0.2em\n"+
		"}\n",
		"stp_Include");

	var createStateElem = function() {
		var e = document.createElement("div");
		e.className = "includeProgressState";
		e.style.display = "none";
		document.body.appendChild(e);
		return e;
	};
	
	var stateElem = createStateElem();


	var showState = function(message) {
		removeChildren(stateElem);
		createTiddlyText(stateElem,message);
		showAnimated(stateElem,true,0);
	};

	var hideState = function() {
		// hide the state the next idle time 
		invokeLater(function() {
			showAnimated(stateElem,false,ANI_DURATION_HIDE_STATE);
		},100,ANIMATION_PRIORITY);
	};
	
	var myProgressFunction = function(message, sender, state, url, params) {
		
		if (state == "Done" || state == "Failed") {
			hideState();
			return;
		}
		
		if (sender == "stp_loadTiddlyWikiStore") {
			idleCount = 0;
			if (state == "Processing")
				showState("Including...");
		} else {
			showState(message);
		}
	};
	return myProgressFunction;
};

twWeb.setProgressFunction(config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction());


//================================================================================
// The "describeNode" macro
//
// Syntax: <<describeNode nodeName {nodeUrl|self}>>
//
config.macros.describeNode = {};
config.macros.describeNode.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	var macroTWcode = wikifier.source.substring(wikifier.matchStart, wikifier.nextMatch);
	createTiddlyText(createTiddlyElement(place,"code"),macroTWcode);

	// node description duplicates are handled when adding, so no "handle only once" here

	var includeURL = tiddler.getIncludeURL(),
	    nodeName = params[0],
	    urlParam = params[1],
	    self = (urlParam == "self");

	if(self) {
		var oldSelf = twWeb.getSelfNodeName();
		if(oldSelf && (oldSelf != nodeName))
			return alert("The \'"+oldSelf+"\' alias is already assigned as the name of the current "+
					"TiddlyWiki; the new attempt to assign \'"+nodeName+"\' is ignored.");
		twWeb.setSelfNodeName(nodeName);
		return;
	}

	var url = resolveUrlFrom(urlParam, includeURL);
	url = stp_resolveURL(url); // if no includeURL

	twWeb.addNodeDesc(nodeName,url);
};

//================================================================================
// The "include" macro
//
// Syntax:	<<include [url:]url [filters:filterLine] [substitute]
//			  [substituteShadows] [hide:hideFlag] [delay:delayDuration]>>
//
config.macros.include = {};
config.macros.include.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	var macroTWcode = wikifier.source.substring(wikifier.matchStart, wikifier.nextMatch),
	    pParams = paramString.parseParams("url",null,true,false,true); // allowEval, cascadeDefaults, names allowed

	var hide = getFlag(pParams, "hide", false) || params.contains('hide');
	if (!hide)
		createTiddlyText(createTiddlyElement(place,"code"),macroTWcode);
	if (twWeb.includeUsages.isUsed(macroTWcode))
		return;
	twWeb.includeUsages.setUsed(macroTWcode);

	var urls = pParams[0]["url"],
	    includeParams = {
		delayMilliSeconds:	parseInt(getParam(pParams,"delay","0")),
		filterLine:		getParam(pParams,"filters","[all[-]]"),
		substitute:		params.contains('substitute'),
		substituteShadows:	params.contains('substituteShadows'),
		noRefresh:		params.contains('noRefresh'),
		importMode:		getParam(pParams,"import",undefined),
		evalTiddlers:		params.contains('eval'),
		wikifyTiddlers:		params.contains('wikify')
	};

	var checkUrlAndInclude = function(url) {

		if(url == 'hide' || url == 'substituteShadows' || url == 'substitute' || url == 'eval' ||
				url == 'wikify' || url == 'noRefresh')
			return;

		twWeb.include(url,includeParams);
	};

	for (var i = 0; urls && i < urls.length; i++)
		checkUrlAndInclude(urls[i]);
};

//================================================================================
// The "reloadIncluded" macro
//
// Syntax: <<reloadIncluded [urls:urlsJSON] [reloadParams:otherReloadParamsJSON]
//		[label:labelText] [tooltip:tooltipText] [class:className]>>
// (for reloadParams, see twWeb.reload)
//
config.macros.reloadIncluded = {};
config.macros.reloadIncluded.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	// parse params
	var pParams = paramString.parseParams("url",null,true,false,true),
	    label    = getParam(pParams,"label","refresh"),
	    tooltip  = getParam(pParams,"tooltip",undefined),
	    elClass  = getParam(pParams,"class"," "), // " " overwrites the default "button" class
	    urlsText = getParam(pParams,"urls",undefined),
	    otherReloadParamsText = getParam(pParams,"reloadParams","{}"),
	    reloadParams = JSON && JSON.parse(otherReloadParamsText) || jQuery.parseJSON(otherReloadParamsText);
	reloadParams.urlOrNodeList = !urlsText ? undefined :
			(JSON && JSON.parse(urlsText) || jQuery.parseJSON(urlsText));
	if(!tooltip) {
		if(reloadParams.urlOrNodeList) {
			tooltip = "refresh '"+reloadParams.urlOrNodeList[0]+"'";
			for(var i = 1; i < reloadParams.urlOrNodeList.length; i++)
				tooltip += ", '"+reloadParams.urlOrNodeList[i]+"'";
			tooltip += (i > 0) ? " nodes" : " node";
		} else
			tooltip = "refresh all included nodes";
	}

	// create button, add handler
	createTiddlyButton(place,label,tooltip,function(){
		var returnHere = function() {
			if(twWeb.hasPendingIncludes()) {
				invokeLater(returnHere,100);
				return;
			} // wait until all the stores are loaded and the page is refreshed
			var t = tiddler.title, te = DEFAULT_VIEW_TEMPLATE;
			story.displayTiddler(this,t,story.chooseTemplateForTiddler(t,te));
		}
		twWeb.reload(reloadParams);
		invokeLater(returnHere,100); // wait a bit for the nodes to unload
	},elClass);
};

//================================================================================
// The "includeState" macro
//
// Syntax: <<includeState>>
//
config.macros.includeState = {};
config.macros.includeState.handler = function(place,macroName,params,wikifier,paramString,tiddler) {
	var getFullState = function () {
		var s = "";
		var includes = twWeb.getIncludedStoresUrls();
		if (!includes.length)
			return "{{noIncludes{\nNo TiddlyWiki is included or including is disabled (see AdvancedOptions)\n}}}\n";
			
		s += "|!Address|!State|\n";
		for (var i = 0; i < includes.length; i++) {
			var inc = includes[i];
			s += "|{{{"+inc+"}}}|";
			var t = twWeb.getState(inc);
			s += t ? "{{{"+t+"}}}" : "included";
			s += "|\n"
		}
		s += "|includeState|k\n";
		return s;
	};
	
	var updateState = function(){
		removeChildren(div);
		wikify(getFullState(),div);
		if (twWeb.hasPendingIncludes())
			invokeLater(updateState,500,UPDATE_STATE_PRIORITY);
	};

	var div = createTiddlyElement(place,"div");
	
	invokeLater(updateState,0,UPDATE_STATE_PRIORITY);
};

//================================================================================
// Change standart formatters

var getFormatterIndex = function(formatterName) {
	for(var i = 0; i < config.formatters.length; i++)
		if(config.formatters[i].name == formatterName)
			return i;
	return null;
}

//--------------------------------------------------------------------------------
// Change the prettyLink formatter so that it
// * recognizes [[text|target]]@nodeName and [[target]]@nodeName syntax
// * takes into account includeURL of the tiddler and propagates inclusion

if(config.options.STP_hijackPrettyLink) {
	var prettyLinkFormatterIndex = getFormatterIndex("prettyLink");
	config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter = config.formatters[prettyLinkFormatterIndex];
	config.formatters[prettyLinkFormatterIndex] = {

		name:  "prettyLink",
		match: "\\[\\[",
		lookaheadRegExp: /\[\[(.*?)(?:\|(~)?(.*?))?\]\](?:(?:@(\w+))(?:@([\w\s\:]+)@)?)?/mg,
		handler: function(w) {

			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {

				// call the formatter
				config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter.handler(w);

				// call the include.handler, if necessary
				var node = lookaheadMatch[4]? lookaheadMatch[4] : undefined,
				    includeURL = w.tiddler? w.tiddler.getIncludeURL() : null,
				    urlParam = node? twWeb.setNodeNotation(node) : (includeURL? includeURL : undefined),
				    target = lookaheadMatch[3]? lookaheadMatch[3] : lookaheadMatch[1],
				    paramString = '"'+urlParam+'" filters:"[['+target+']]" hide noRefresh ';
				if(lookaheadMatch[5])
					paramString += lookaheadMatch[5];
				if(urlParam)
					config.macros.include.handler(w.output,"include",
						paramString.readMacroParams(true),w,paramString,w.tiddler);

				// move nextMatch according to this.lookaheadRegExp, not original prettyLink
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	};
}

//--------------------------------------------------------------------------------
// Change the image formatter so that it
// * takes into account includeURL of the tiddler and recalcs relative urls

if(config.options.STP_hijackImageFormatter) {
	var imageFormatterIndex = getFormatterIndex("image");
	config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler = config.formatters[imageFormatterIndex].handler;
	config.formatters[imageFormatterIndex].handler = function(w) {

		var lastChildBeforeHandling = w.output.lastChild;
		config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler.apply(this,arguments);

		if(w.output.lastChild != lastChildBeforeHandling) {

			var img = w.output.lastChild,
			    includeURL = w.tiddler ? w.tiddler.getIncludeURL() : "",
			    imgSrc = jQuery(img).attr("src");

			// take includeURL into account:
			img.src = resolveUrlFrom(imgSrc, includeURL);
		}
	}
}

//================================================================================
// Add inline-management tools by hijacking .edit.handler

config.extensions.SharedTiddlersPlugin.orig_editHandler = config.macros.edit.handler;
config.macros.edit.handler = function(place,macroName,params,wikifier,paramString,tiddler) {
	var includeUrl = tiddler.getIncludeURL();
	if(params[0] == "text" && includeUrl){ // only for "text", not other fields
		var e = createTiddlyElement(null,"div");
		e.className = "manageIncludedPanel";
		createTiddlyText(e,"manage the included tiddler: ");

		// go to the source
		var sourceUrl = includeUrl + "#[["+tiddler.title+"]]";
		createExternalLink(e, sourceUrl, "open in the source TiddlyWiki");
		// view the link to the source
		createTiddlyText(e," (");
		createTiddlyButton(e,"view link","view the link to the source",function(e){
			var popup = Popup.create(this);
			createTiddlyText(popup,sourceUrl);
			Popup.show();
			var ev = e || window.event;
			ev.cancelBubble = true;
			if(ev.stopPropagation)
				ev.stopPropagation();
			return false;
		}," ");
		createTiddlyText(e,")");

		// import
		if(!readOnly) {
			createTiddlyText(e," | ");
			createTiddlyButton(e,"import","import this tiddler",function(){
				twWeb.importAndLog(tiddler,1);
			 }," ");
		}

		// reload
		createTiddlyText(e," | ");
		config.macros.reloadIncluded.handler(e,"",null,null,'urls:\'["'+includeUrl+'"]\'',tiddler);

		// other actions

		// if the read only mode is not set, display all tools otherwise ...
		place.appendChild(e);
	}
	return config.extensions.SharedTiddlersPlugin.orig_editHandler(place,macroName,params,wikifier,paramString,tiddler);
};

//================================================================================
// Perform plugin startup tasks

// add this for the "install only once" check (which also prevents conflicts with abego.IncludePlugin)
// (this is also deprecated API for backward compability)
abego.TiddlyWikiIncluder = {
	getIncludes:	twWeb.getIncludedStoresUrls,
	getState:	twWeb.getState,
	getStore:	twWeb.getStore
};
attachToStore();
invokeLater(includeFromIncludeList,100);

// add several more methods to the "API namespace"

window.sharedTiddlersAPI.getIncludes  = twWeb.getIncludedStoresUrls;
window.sharedTiddlersAPI.getState     = twWeb.getState;
window.sharedTiddlersAPI.getStore     = twWeb.getStore;
window.sharedTiddlersAPI.importAndLog = twWeb.importAndLog;

// iterates over all tiddlers of "the store" and all tiddlers of included (and loaded) stores
//
window.sharedTiddlersAPI.forReallyEachTiddler = function(callback) {
	var caller = function() {
		store.forEachTiddler(callback);
	};
	getFunctionUsingForReallyEachTiddler(caller).call(store);		
};
})();
//%/ //